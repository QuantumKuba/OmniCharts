[INDICATOR name=ZLEMA, version=1.0.0]

// Input properties
prop('src', { type: 'source', def: 'hlc3', label: 'Source' });
prop('enableKalman', { type: 'string', def: 'ON', label: 'Kalman Filter', options: ['ON', 'OFF'] });
prop('fast', { type: 'integer', def: 8, label: 'Fast Period', min: 1 });
prop('medium', { type: 'integer', def: 21, label: 'Medium Period', min: 1 });
prop('slow', { type: 'integer', def: 55, label: 'Slow Period', min: 1 });
prop('showCross', { type: 'boolean', def: true, label: 'Show Cross' });
prop('colorFast', { type: 'color', def: '#FFA500', label: 'Fast Color' });
prop('colorMedium', { type: 'color', def: '#00FFFF', label: 'Medium Color' });
prop('colorSlow', { type: 'color', def: '#888888', label: 'Slow Color' });
prop('prec', { type: 'integer', def: autoPrec(), label: 'Precision' });

// Define overlay settings
this.specs = {
    name: `ZLEMA ${$props.medium}`,
    settings: { precision: $props.prec, zIndex: 0 }
};

// Helper function for plotting shapes
this.plotshape = function(cond, settings) {
    if (!cond) return;
    
    // Only store values when a condition is met - no array of undefined values
    const signalData = [];
    
    const t = se.t;
    const shape = {
        time: t,
        price: settings.location === 'belowbar' ? low[0] * 0.999 : high[0] * 1.001,
        shape: settings.text || '▲',
        color: settings.color || 'green',
    };
    
    // Add this single point to our signals data
    signalData.push([t, shape]);
    
    // Use Label overlay type for shapes - only passing data when a signal occurs
    Label(signalData, {
        name: `${settings.text || 'signal'}-${t}`,
        color: settings.color || 'green'
    });
};

[UPDATE]

// Get source based on property
let src;
if ($props.src === 'open') src = open;
else if ($props.src === 'high') src = high;
else if ($props.src === 'low') src = low;
else if ($props.src === 'close') src = close;
else if ($props.src === 'hl2') src = ts((high[0] + low[0]) / 2);
else if ($props.src === 'hlc3') src = ts((high[0] + low[0] + close[0]) / 3);
else if ($props.src === 'ohlc4') src = ts((open[0] + high[0] + low[0] + close[0]) / 4);
else src = close;

// Apply Kalman filter if enabled
let base = $props.enableKalman === 'ON' 
    ? kalmanFilter(src)
    : src;

// Zero-Lag EMA implementation using standard library functions
// First create lag-adjusted time series for each period
const fastLag = Math.floor(($props.fast - 1) / 2);
const mediumLag = Math.floor(($props.medium - 1) / 2);
const slowLag = Math.floor(($props.slow - 1) / 2);

// Create lag-adjusted time series (double the src minus the lagged src)
let fastSrc = ts(0);
let mediumSrc = ts(0); 
let slowSrc = ts(0);

// Calculate lag-adjusted values using the formula: 2 * src[0] - src[lag]
fastSrc[0] = 2 * base[0] - base[fastLag];
mediumSrc[0] = 2 * base[0] - base[mediumLag];
slowSrc[0] = 2 * base[0] - base[slowLag];

// Apply EMA to the lag-adjusted time series
const ma1_data = ema(fastSrc, $props.fast);
const ma2_data = ema(mediumSrc, $props.medium);
const ma3_data = ema(slowSrc, $props.slow);

// Plot lines
if (ma1_data !== undefined && ma1_data !== null) {
    Spline(ma1_data, { 
        name: `Fast ZLEMA (${$props.fast})`,
        color: $props.colorFast,
        lineWidth: 2,
        skipNaN: true 
    });
}

if (ma2_data !== undefined && ma2_data !== null) {
    Spline(ma2_data, { 
        name: `Medium ZLEMA (${$props.medium})`,
        color: $props.colorMedium,
        lineWidth: 2,
        skipNaN: true 
    });
}

if (ma3_data !== undefined && ma3_data !== null) {
    Spline(ma3_data, { 
        name: `Slow ZLEMA (${$props.slow})`,
        color: $props.colorSlow,
        lineWidth: 2,
        skipNaN: true 
    });
}

// Plot crosses if enabled and we have valid data
if ($props.showCross && ma1_data && ma2_data) {
    // Check for crossover (fast crosses above medium)
    const isCrossover = ma1_data[0] > ma2_data[0] && ma1_data[1] <= ma2_data[1];
    
    // Check for crossunder (fast crosses below medium)
    const isCrossunder = ma1_data[0] < ma2_data[0] && ma1_data[1] >= ma2_data[1];
    
    // Crossover - buy signal
    this.plotshape(isCrossover, {
        text: '▲', 
        color: 'green',
        location: 'belowbar'
    });
    
    // Crossunder - sell signal
    this.plotshape(isCrossunder, {
        text: '▼',
        color: 'red',
        location: 'abovebar'
    });
}
